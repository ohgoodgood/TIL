---
Title: TIL_2024-08-14
Date: 2024-08-14
Category: [HTML_CSS]
Tags: [position, inset, stacking context, z-index, vh, vw, aspect-ratio, object-fit, cover image]
---

# Position(계속), 스태킹 컨텍스트, 화면 상단 커버 이미지 만들기

## Position
### 좌표 속성값에 `0`을 설정했을 때의 효과
- `position: absolute;`인 요소에 `left: 0;`과 `right: 0;`을 같이 설정하면, 컨테이닝 블록의 가로 공간은 모두 해당 요소의 가용공간이 된다. 양쪽으로 잡아 당기는 개념.
- 마찬가지로 `top: 0;`, `bottom: 0;`을 함께 설정하면, 컨테이닝 블록의 세로 공간은 모두 해당 요소의 가용공간이 된다.
- 따라서 네 방향의 좌표 속성을 모두 0으로 설정하면, `position: absolute;`가 설정된 자식요소는 (컨테이닝 블록에 해당하는)부모 요소의 전체 영역을 가용 공간으로 가진다.
- 따라서 자체적인 너비와 높이를 지닌 `<img>` 요소, 또는 `width`와 `height`값이 별도로 설정된 요소가 아니라면 이 상황에서 자식 요소는 부모 요소의 전체 영역을 가득 채운다.
- 가용공간을 잡아 당겨 늘리고, 그 공간을 요소가 채운다는 관점으로 이해하기

### `inset` 속성
- `inset: 0 0 0 0;`으로 설정하면 `top`, `right`, `bottom`, `left` 모두 `0`으로 설정한 것과 같은 효과
- 이 때 시각적 표현은 자식요소의 사방에 `margin`을 준 것과 똑같아 보인다는 점에 유의!
- `inset` 속성값으로 특정 수치를 지정하면, 자식요소의 크기가 정해진다.
- 이 때 `inset` 속성은 `margin`, `padding` 등 모든 요소를 정해진 크기 안에서 자동 계산해 준다. 즉, 다른 속성이 추가되어도 정해진 자식요소의 크기에는 변동이 없게 한다. 유연한 속성으로, 활용도가 높다.
- 이렇게 자식요소의 크기를 고정한 후에는 `margin`으로 상하좌우 정렬도 가능하다.

<br>

## 스태킹 컨텍스트(쌓임 컨텍스트 또는 쌓임 맥락) Stacking Context
### 기본 레이어링 규칙 (쌓임 순서)
1. 마크업 작성 순서: HTML 문서 상의 마크업 순서대로, 나중에 작성된 요소가 위로(앞으로) 쌓인다.
2. `position: relative;`가 적용된 요소는 마크업 순서와 상관 없이 앞으로 나온다.


### `z-index`
- 쌓임 순서를 수동으로 조절해주는 속성
- 기본값은 `auto;`
- 정수 값을 지정할 수 있으며, 값이 큰 요소가 더 위에 쌓인다. (***그러나 이는 절대적이지 않다. 이하 내용 참고***)
- `position` 속성값이 `static;`이 아닌 요소에만 적용된다. (예외: flex item은 `position` 속성 없이도 단독으로 `z-index` 값을 적용 받을 수 있다.)

### 새로운 스태킹 컨텍스트 생성하기
- `z-index`를 통해 특정 요소 내부에 새로운 스태킹 컨텍스트를 생성할 수 있다.
- 부모 요소의 `z-index`에 `auto;`가 아닌 다른 값이 지정되면, 그 부모 요소는 새로운 스태킹 컨텍스트를 형성하며, 자식 요소는 그 스태킹 컨텍스트 내에서 다시 쌓인다. 즉, 자식 요소의 `z-index`의 기준점은 부모 요소가 새로 형성한 스태킹 컨텍스트가 된다.
- 기본적으로 어떤 요소에 `z-index: -1;`을 설정하면, 최초의 스태킹 컨텍스트인 `<html>`요소 스태킹 컨텍스트를 기준으로 하기 때문에 `<html>`요소 내부에서 맨 뒤, 즉 `전체 문서에서` 맨 뒤로 쌓인다.
- 여기서 그 요소의 부모요소에 새로운 스태킹 컨텍스트를 형성하면, 그 요소는 `전체 문서에서`가 아닌 `부모요소 내부에서` 맨 뒤로 쌓인다.

#### 유의해야 할 상황
- 요소1(부모요소A의 자식요소)과 요소2(부모요소B의 자식요소)가 있다고 하자.
- 요소1에는 `z-index: 9999;`가, 요소2에는 `z-index: 1;`이 설정되어 있다.
- 일반적으로 당연히 요소1이 더 위로 쌓이지만, 그렇지 않을 수도 있다.
- 부모요소A와 부모요소B가 각각의 스태킹 컨텍스트를 형성하고 있다면, 부모요소A와 부모요소B의 `z-index`값을 먼저 비교해야 한다.
- 이 때 더 높은 `z-index`값을 가진 부모요소의 자식요소는, 자식요소 본인의 `z-index`값과 관계 없이 더 낮은 `z-index`값을 가진 부모요소의 자식요소보다 위에 쌓인다.
- 위의 사례에서, 부모요소A에 `z-index: 1;`이, 부모요소B에 `z-index: 100;`이 설정되어 있다면, 요소1보다 요소2가 위에 쌓인다.
- 즉, 자식요소는 부모요소의 스태킹 컨텍스트를 벗어날 수 없으며, 부모요소의 `z-index`가 자식요소의 `z-index`보다 우선적으로 적용된다.

<br>

## 페이지 상단 가득 채우는 커버 이미지 만들기
- 페이지 상단의 커버 이미지를 만들기 위해 `<body>`요소의 직계 자식 요소로 `<img>`요소를 작성했을 때,
- `<img>`요소에 `height: 100%`를 적용하면 효과가 나타나지 않는다.
- 이는 `height: 100%` 속성이 직계 상위요소의 `height`값을 기준으로 하는데, 현재 직계 상위요소인 `<body>`요소의 `height`값은 `auto;`로서 내부 요소의 높이에 따라 결정되기 때문이다.
- 즉 내부요소의 높이는 부모요소의 높이에 따라 정해지려고 하고, 부모요소의 높이는 내부요소의 높이에 따라 정해지려고 하는 상황이기 때문에 말이 안 된다.

### 레이아웃 관점 - `vh`, `vw`, `aspect-ratio`
- 위와 같은 상황에서 `vh` 단위를 활용할 수 있다. 이 단위값은 `<body>`가 아닌 `viewport`를 기준으로 높이를 설정할 수 있게 해준다.
- 마찬가지 원리로 너비값에 대해서는 `vw` 단위를 사용할 수 있다.
- 둘을 결합하여 `height: 40vw;`와 같이 설정하면, 요소의 너비와 높이 비율을 유지하면서 `viewport`의 변화에 대응하도록 할 수 있다.
- 그러나 사실은 `aspect-ratio` 속성이 더 범용성이 좋고, 자주 사용된다. 이 속성은 `<body>`의 직계 자식요소가 아닌 요소에도 모두 적용할 수 있기 때문이다.
- `aspect-ratio`와 `max-width` 속성을 함께 사용하면, 이미지의 비율은 유지되면서도 이미지가 너무 커지지는 않게 할 수 있다.
- `vh`와 `vw`단위를 함께 사용하는 것, 또는 `aspect-ratio` 속성을 사용하는 것은 모두 레이아웃 관점에서이다. 이미지, 비디오 등의 콘텐츠가 로드될 레이아웃을 미리 확보해 두는 개념

### 컴포넌트 관점
- 이제 레이아웃의 비율이 설정되었으니, 이미지 요소에 `width: 100%;`, `height: 100%;`를 설정해 준다. 준비된 레이아웃을 가득 채우도록.
- 그런데 설정된 레이아웃의 비율과 이미지 자체의 비율이 다른 경우, 이미지의 비율이 찌그러져서 나타난다.
- 이 때 `object-fit: cover;` 속성을 지정하면 해결!
- CSS 문서 상의 `background-image`에 대해 `background-size: cover;` 속성이 하던 역할을, 마크업 문서 상의 `<img>`요소에 대해서는 `object-fit: cover;`속성이 수행해주는 것이다. 이미지와 비디오에 모두 사용할 수 있다.

### 커버 이미지 위에 `<h1>`등의 콘텐츠를 배치할 때
- `<img>`요소와 `<h1>`요소 둘 중 하나에는 `position: absolute;`속성을 지정해야 한다.
- 그런데 `<img>`요소는 어차피 배경 이미지로서 그대로 있고, `<h1>`요소에 내용 수정, 배치 등 편집이 이루어질 가능성이 크다.
- 따라서 `<img>`요소에 `position: absolute;`속성을 지정해 뒤로 보내 버리고, `<h1>`요소는 `flex-item`으로 설정해 두는 것이 (`<img>`요소와 `<h1>`요소의 부모 요소를 `flex-container`로 만드는 것이) 편하다.
- (참고) 이 경우 `<img>`요소에 `position: absolute;`를 설정하고 나서, `left: 0;`, `top: 0;`을 명시적으로 작성해주는 것이 좋다.